; Byte code assembler file
;
;
    ; Import io as io from ::_sfl::io
    LOAD_CONST          "io"
    LOAD_CONST          "::_sfl::io"
    IMPORT
    STORE_ID            io

    ;
    ; Create object
    ;

    ; create method
    LOAD_CONST          @func3
    MAKE_METHOD
    STORE_ID            func3

    ; create method
    LOAD_CONST          @func1
    MAKE_METHOD
    STORE_ID            func1

    ; create method
    LOAD_CONST          @func2
    MAKE_METHOD
    STORE_ID            func2

    ; method to name mapping
    LOAD_ID             func1
    LOAD_CONST          "func1"
    LOAD_ID             func3
    LOAD_CONST          "func3"
    LOAD_ID             func2
    LOAD_CONST          "func2"
    ; flags
    LOAD_CONST          0
    ; class name
    LOAD_CONST          "myclass"
    BUILD_CLASS         $3
    STORE_ID            myclass


    ; a = 2;
    LOAD_CONST          2
    STORE_ID            a

    ; a = myclass.func(a);
    LOAD_ID             a
    LOAD_CONST          3
    LOAD_ID             myclass
    CALL_METHOD         "func2", $2
    STORE_ID            a


    ; io.print(a);
    LOAD_ID             a
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    ; a = myclass.func(a);
    LOAD_ID             a
    LOAD_CONST          2
    LOAD_ID             myclass
    CALL_METHOD         "func2", $2
    STORE_ID            a

    ; io.print(a);
    LOAD_ID             a
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    ; return a;
    LOAD_ID             a
    RETURN




    ;  io.print(myclass.func2());
    LOAD_ID             myclass
    CALL_METHOD         "func2", $0
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    LOAD_CONST          4
    RETURN


    ; a = 10
    LOAD_CONST          10
    STORE_ID            a

    SETUP_LOOP          #end_loop1
#loop1:
    LOAD_ID             a
    LOAD_CONST          20
    COMPARE_OP          OP_NE
    JUMP_IF_FALSE       #end_loop1_pb
    POP_TOP

    ; a = a + 1
    LOAD_ID             a
    LOAD_CONST          1
    BINARY_ADD
    STORE_ID            a


    ; if (a == 15)
    LOAD_ID             a
    LOAD_CONST          15
    COMPARE_OP          OP_EQ
    JUMP_IF_FALSE       #end_if1
    POP_TOP

    ; continue
    CONTINUE_LOOP       #loop1
#end_if1:
    POP_TOP

    ; if (a == 18)
    LOAD_ID             a
    LOAD_CONST          18
    COMPARE_OP          OP_EQ
    JUMP_IF_FALSE       #end_if2
    POP_TOP

    ; break
    BREAK_LOOP
#end_if2:
    POP_TOP

    ; io.print(a)
    LOAD_ID             a
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    JUMP_ABSOLUTE      #loop1

#end_loop1_pb:
    POP_BLOCK
#end_loop1:

    ; io.print("All done!")
    LOAD_CONST          "All done!"
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    ; io.print(a)
    LOAD_ID             a
    LOAD_ID             io
    CALL_METHOD         "print", $1
    POP_TOP

    ; return a as exit code
    LOAD_ID             a
    RETURN


; ====================================================================
@frame func1
    ; a = 10
    LOAD_CONST          10
    STORE_ID            a

    LOAD_CONST          50
    STORE_ID            b

    LOAD_ID             a
    LOAD_ID             b
    BINARY_ADD
    STORE_ID            c

    LOAD_CONST          25
    LOAD_ID             c
    COMPARE_OP          OP_GT
    JUMP_IF_FALSE       #no_ret

    LOAD_CONST          "Jah!"
    RETURN

#no_ret:
    LOAD_CONST          "Neen"
    RETURN



; ====================================================================
@frame func2
    STORE_ID            a
    STORE_ID            b
    LOAD_ID             a
    LOAD_ID             b
    BINARY_MUL
    RETURN


; ====================================================================
@frame func3
    LOAD_CONST          "Func3 is called!!"
    RETURN