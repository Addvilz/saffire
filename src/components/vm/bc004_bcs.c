/**
 * Generated bytecode from src/components/vm/bc004.bcs
 */


t_bytecode *generate_dummy_bytecode_bc004_bcs_main(void);
t_bytecode *generate_dummy_bytecode_bc004_bcs_func1(void);
t_bytecode *generate_dummy_bytecode_bc004_bcs_func2(void);
t_bytecode *generate_dummy_bytecode_bc004_bcs_func3(void);
/**
 *
 */
t_bytecode *generate_dummy_bytecode_bc004_bcs_main(void) {
    char byte_code[] = 
        "\x81\x00\x00"         // LOAD_CONST          "io"
        "\x81\x01\x00"         // LOAD_CONST          "::_sfl::io"
        "\x7F"                 // IMPORT
        "\x80\x00\x00"         // STORE_ID            io
        "\x81\x02\x00"         // LOAD_CONST          @func3
        "\x71"                 // MAKE_METHOD
        "\x80\x01\x00"         // STORE_ID            func3
        "\x81\x03\x00"         // LOAD_CONST          @func1
        "\x71"                 // MAKE_METHOD
        "\x80\x02\x00"         // STORE_ID            func1
        "\x81\x04\x00"         // LOAD_CONST          @func2
        "\x71"                 // MAKE_METHOD
        "\x80\x03\x00"         // STORE_ID            func2
        "\x82\x02\x00"         // LOAD_ID             func1
        "\x81\x05\x00"         // LOAD_CONST          "func1"
        "\x82\x01\x00"         // LOAD_ID             func3
        "\x81\x06\x00"         // LOAD_CONST          "func3"
        "\x82\x03\x00"         // LOAD_ID             func2
        "\x81\x07\x00"         // LOAD_CONST          "func2"
        "\x81\x08\x00"         // LOAD_CONST          0
        "\x81\x09\x00"         // LOAD_CONST          "myclass"
        "\x93\x03\x00"         // BUILD_CLASS         $3
        "\x80\x04\x00"         // STORE_ID            myclass
        "\x81\x0A\x00"         // LOAD_CONST          2
        "\x80\x05\x00"         // STORE_ID            a
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x0B\x00"         // LOAD_CONST          3
        "\x82\x04\x00"         // LOAD_ID             myclass
        "\xC0\x07\x00\x02\x00" // CALL_METHOD         "func2", $2
        "\x80\x05\x00"         // STORE_ID            a
        "\x82\x05\x00"         // LOAD_ID             a
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x0A\x00"         // LOAD_CONST          2
        "\x82\x04\x00"         // LOAD_ID             myclass
        "\xC0\x07\x00\x02\x00" // CALL_METHOD         "func2", $2
        "\x80\x05\x00"         // STORE_ID            a
        "\x82\x05\x00"         // LOAD_ID             a
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x73"                 // RETURN
        "\x82\x04\x00"         // LOAD_ID             myclass
        "\xC0\x07\x00\x00\x00" // CALL_METHOD         "func2", $0
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x81\x0D\x00"         // LOAD_CONST          4
        "\x73"                 // RETURN
        "\x81\x0E\x00"         // LOAD_CONST          10
        "\x80\x05\x00"         // STORE_ID            a
        "\x90\x47\x00"         // SETUP_LOOP          #end_loop1
    // #loop1:
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x0F\x00"         // LOAD_CONST          20
        "\x95\x02\x00"         // COMPARE_OP          OP_NE
        "\x85\x3A\x00"         // JUMP_IF_FALSE       #end_loop1_pb
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x10\x00"         // LOAD_CONST          1
        "\x17"                 // BINARY_ADD
        "\x80\x05\x00"         // STORE_ID            a
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x11\x00"         // LOAD_CONST          15
        "\x95\x01\x00"         // COMPARE_OP          OP_EQ
        "\x85\x04\x00"         // JUMP_IF_FALSE       #end_if1
        "\x01"                 // POP_TOP
        "\x92\x9F\x00"         // CONTINUE_LOOP       #loop1
    // #end_if1:
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x81\x12\x00"         // LOAD_CONST          18
        "\x95\x01\x00"         // COMPARE_OP          OP_EQ
        "\x85\x02\x00"         // JUMP_IF_FALSE       #end_if2
        "\x01"                 // POP_TOP
        "\x74"                 // BREAK_LOOP
    // #end_if2:
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x86\x9F\x00"         // JUMP_ABSOLUTE      #loop1
    // #end_loop1_pb:
        "\x72"                 // POP_BLOCK
    // #end_loop1:
        "\x81\x13\x00"         // LOAD_CONST          "All done!"
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x82\x00\x00"         // LOAD_ID             io
        "\xC0\x0C\x00\x01\x00" // CALL_METHOD         "print", $1
        "\x01"                 // POP_TOP
        "\x82\x05\x00"         // LOAD_ID             a
        "\x73"                 // RETURN
    ;
    t_bytecode *bc = (t_bytecode *)smm_malloc(sizeof(t_bytecode));
    bzero(bc, sizeof(t_bytecode));
    bc->stack_size = 25;
    bc->code_len = sizeof(byte_code);
    bc->code = smm_malloc(bc->code_len);
    memcpy(bc->code, byte_code, bc->code_len);

    bc->constants = NULL;   // Important to start constants and identifiers on NULL
    bc->identifiers = NULL;

    // constants
    _new_constant_string(bc, "io");
    _new_constant_string(bc, "::_sfl::io");
    _new_constant_code(bc, generate_dummy_bytecode_bc004_bcs_func3());
    _new_constant_code(bc, generate_dummy_bytecode_bc004_bcs_func1());
    _new_constant_code(bc, generate_dummy_bytecode_bc004_bcs_func2());
    _new_constant_string(bc, "func1");
    _new_constant_string(bc, "func3");
    _new_constant_string(bc, "func2");
    _new_constant_long(bc, 0);
    _new_constant_string(bc, "myclass");
    _new_constant_long(bc, 2);
    _new_constant_long(bc, 3);
    _new_constant_string(bc, "print");
    _new_constant_long(bc, 4);
    _new_constant_long(bc, 10);
    _new_constant_long(bc, 20);
    _new_constant_long(bc, 1);
    _new_constant_long(bc, 15);
    _new_constant_long(bc, 18);
    _new_constant_string(bc, "All done!");

    // identifier names
    _new_name(bc, "io");
    _new_name(bc, "func3");
    _new_name(bc, "func1");
    _new_name(bc, "func2");
    _new_name(bc, "myclass");
    _new_name(bc, "a");
    
    return bc;
}



/**
 *
 */
t_bytecode *generate_dummy_bytecode_bc004_bcs_func1(void) {
    char byte_code[] = 
        "\x81\x00\x00"         // LOAD_CONST          10
        "\x80\x00\x00"         // STORE_ID            a
        "\x81\x01\x00"         // LOAD_CONST          50
        "\x80\x01\x00"         // STORE_ID            b
        "\x82\x00\x00"         // LOAD_ID             a
        "\x82\x01\x00"         // LOAD_ID             b
        "\x17"                 // BINARY_ADD
        "\x80\x02\x00"         // STORE_ID            c
        "\x81\x02\x00"         // LOAD_CONST          25
        "\x82\x02\x00"         // LOAD_ID             c
        "\x95\x03\x00"         // COMPARE_OP          OP_GT
        "\x85\x04\x00"         // JUMP_IF_FALSE       #no_ret
        "\x81\x03\x00"         // LOAD_CONST          "Jah!"
        "\x73"                 // RETURN
    // #no_ret:
        "\x81\x04\x00"         // LOAD_CONST          "Neen"
        "\x73"                 // RETURN
    ;
    t_bytecode *bc = (t_bytecode *)smm_malloc(sizeof(t_bytecode));
    bzero(bc, sizeof(t_bytecode));
    bc->stack_size = 25;
    bc->code_len = sizeof(byte_code);
    bc->code = smm_malloc(bc->code_len);
    memcpy(bc->code, byte_code, bc->code_len);

    bc->constants = NULL;   // Important to start constants and identifiers on NULL
    bc->identifiers = NULL;

    // constants
    _new_constant_long(bc, 10);
    _new_constant_long(bc, 50);
    _new_constant_long(bc, 25);
    _new_constant_string(bc, "Jah!");
    _new_constant_string(bc, "Neen");

    // identifier names
    _new_name(bc, "a");
    _new_name(bc, "b");
    _new_name(bc, "c");
    _new_name(bc, "OP_GT");
    
    return bc;
}



/**
 *
 */
t_bytecode *generate_dummy_bytecode_bc004_bcs_func2(void) {
    char byte_code[] = 
        "\x80\x00\x00"         // STORE_ID            a
        "\x80\x01\x00"         // STORE_ID            b
        "\x82\x00\x00"         // LOAD_ID             a
        "\x82\x01\x00"         // LOAD_ID             b
        "\x19"                 // BINARY_MUL
        "\x73"                 // RETURN
    ;
    t_bytecode *bc = (t_bytecode *)smm_malloc(sizeof(t_bytecode));
    bzero(bc, sizeof(t_bytecode));
    bc->stack_size = 25;
    bc->code_len = sizeof(byte_code);
    bc->code = smm_malloc(bc->code_len);
    memcpy(bc->code, byte_code, bc->code_len);

    bc->constants = NULL;   // Important to start constants and identifiers on NULL
    bc->identifiers = NULL;

    // constants

    // identifier names
    _new_name(bc, "a");
    _new_name(bc, "b");
    
    return bc;
}



/**
 *
 */
t_bytecode *generate_dummy_bytecode_bc004_bcs_func3(void) {
    char byte_code[] = 
        "\x81\x00\x00"         // LOAD_CONST          "Func3 is called!!"
        "\x73"                 // RETURN
    ;
    t_bytecode *bc = (t_bytecode *)smm_malloc(sizeof(t_bytecode));
    bzero(bc, sizeof(t_bytecode));
    bc->stack_size = 25;
    bc->code_len = sizeof(byte_code);
    bc->code = smm_malloc(bc->code_len);
    memcpy(bc->code, byte_code, bc->code_len);

    bc->constants = NULL;   // Important to start constants and identifiers on NULL
    bc->identifiers = NULL;

    // constants
    _new_constant_string(bc, "Func3 is called!!");

    // identifier names
    
    return bc;
}




